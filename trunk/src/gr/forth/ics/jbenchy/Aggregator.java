package gr.forth.ics.jbenchy;

import gr.forth.ics.jbenchy.fluent.ReportBuilder;

/**
 * An aggregator records measurements defined by a schema,
 * and then allows aggregated reports to be generated according to a number of variables.
 * 
 * <p>
 * Each stored record must conform to the {@link #getSchema() schema}
 * of this aggregator, that is, have a value (or binding) for each variable defined in the schema
 * with a compatible type.
 * <p>
 * Reports are generated by picking a set of variables. All distinct combinations of
 * values for this set are taken, and each different combination groups all records having
 * those exact variable bindings. The value of each combination is the aggregation of 
 * the grouped records, according to an {@link Aggregate} function.
 * <p>
 * For example, if there were these stored records:
 * <table border="1">
 * <thead>
 * <tr>
 * <th>COLOR</th>
 * <th>SIZE</th>
 * <th>VALUE</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>"RED"</td>
 * <td>"BIG"</td>
 * <td>15.0</td>
 * </tr>
 * <tr>
 * <td>"RED"</td>
 * <td>"SMALL"</td>
 * <td>20.0</td>
 * </tr>
 * <tr>
 * <td>"BLUE"</td>
 * <td>"BIG"</td>
 * <td>20.0</td>
 * </tr>
 * <tr>
 * <td>"BLUE"</td>
 * <td>"SMALL"</td>
 * <td>25.0</td>
 * </tr>
 * <tr>
 * <td>"YELLOW"</td>
 * <td>"BIG"</td>
 * <td>23.0</td>
 * </tr>
 * </tbody>
 * </table>
 * <p>
 * A report of the average for each distinct "COLOR" (which would be requested
 * with: <tt>averageOf("VALUE").per("COLOR")</tt>, returning a {@link Records} object)
 * would yield these results:
 * 
 * <table border="1">
 * <thead>
 * <tr>
 * <th>COLOR</th>
 * <th><tt>null</tt></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>RED</td>
 * <td>17.5</td>
 * </tr>
 * <tr>
 * <td>BLUE</td>
 * <td>22.5</td>
 * </tr>
 * <tr>
 * <td>YELLOW</td>
 * <td>23.0</td>
 * </tr>
 * </tbody>
 * </table>
 * <p>
 * The column keyed with <tt>null</tt> contains the results of the aggregations. The value for
 * this column, for each record in the results, can also be accessed with {@link Record#getValue()} method.
 * <p>
 * The max value per distinct size (accordingly,
 * <tt>maxOf("VALUE").per("SIZE")</tt>) would yield:
 * 
 * <table border="1">
 * <thead>
 * <tr>
 * <th>SIZE</th>
 * <th><tt>null</tt></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>SMALL</td>
 * <td>25.0</td>
 * </tr>
 * <tr>
 * <td>BIG</td>
 * <td>23.0</td>
 * </tr>
 * </tbody>
 * </table>
 * <p>
 * Similarly, the count of all records (or simply <tt>count().perAll()</tt>), regardless
 * of variables, would yield:
 * <table border="1">
 * <thead>
 * <tr>
 * <th><tt>null</tt></th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 * <td>5</td>
 * </tr>
 * </tbody>
 * </table>
 * <p>
 * The semantics of the reports generation are strictly equivalent to SQL's GROUP BY clause.
 * <p>
 * The results can be ordered (see {@link Order} and {@link Orders}) and filtered
 * (see {@link Filter} and {@link Filters}), by prepending the <tt>report()</tt> calls with
 * <tt>ordered()</tt> and/or <tt>restricted()</tt> calls, in chained method calls fashion.
 * <p>
 * For example, to order colors lexicographically, and exclude "YELLOW", this would be
 * written:
 * <pre>
 * ordered(Orders.asc("COLOR")).filtered(Filters.notEq("COLOR", "YELLOW")).sumOf("...").per(..., "COLOR");
 * </pre>
 * 
 * @see Record
 * @see ReportBuilder
 * @see Order
 * @see Orders
 * @see Filter
 * @see Filters
 * @author andreou
 */
public interface Aggregator extends ReportBuilder {
    /**
     * Stores a single record into this aggregator. The record must have a non-null,
     * compatible to its type, value for each variable required by the
     * {@link #getSchema() schema} of this aggregator.
     * @param record the record to be recorded
     */
    void record(Record record);
    
    /**
     * Returns the schema that stored records in this aggregator must conform to.
     */
    Schema getSchema();

    /**
     * Returns the name of this aggregator.
     */
    String getName();
    
    /**
     * Creates an aggregator with the same schema and state as this, and additionally
     * with a variable bound to a value. This variable/value binding will be implicitly
     * recorded whenever a record is recorded to the created aggregator.
     * <p>
     * This can be used to create an Aggregator that simplifies recording and reporting
     * for parts of an applications where some variable/value bindings are constant.
     * This eliminates the need to redundantly add constant bindings to the stored records.
     * <p>
     * Reports generated by the returned aggregator have an implicit filter which returns
     * only records that have the variable/value binding.
     * 
     * @param variable the variable to fix to a specific value
     * @param value the value that the given variable will have in records
     * stored by the returned aggregator
     * @return an aggregator based on this aggregator, which implicitly adds the
     * provided binding to stored records, and only reports records that conform
     * to this binding
     */
    Aggregator with(Object variable, Object value);
}
